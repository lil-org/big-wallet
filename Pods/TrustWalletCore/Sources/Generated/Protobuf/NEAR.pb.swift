// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: NEAR.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Public key with type
public struct TW_NEAR_Proto_PublicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Key type
  public var keyType: UInt32 = 0

  /// The public key data
  public var data: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Permissions for a function call
public struct TW_NEAR_Proto_FunctionCallPermission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// uint128 / big endian byte order
  public var allowance: Data = Data()

  public var receiverID: String = String()

  public var methodNames: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Full access
public struct TW_NEAR_Proto_FullAccessPermission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Access key: nonce + permission
public struct TW_NEAR_Proto_AccessKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Nonce
  public var nonce: UInt64 = 0

  /// Permission
  public var permission: TW_NEAR_Proto_AccessKey.OneOf_Permission? = nil

  public var functionCall: TW_NEAR_Proto_FunctionCallPermission {
    get {
      if case .functionCall(let v)? = permission {return v}
      return TW_NEAR_Proto_FunctionCallPermission()
    }
    set {permission = .functionCall(newValue)}
  }

  public var fullAccess: TW_NEAR_Proto_FullAccessPermission {
    get {
      if case .fullAccess(let v)? = permission {return v}
      return TW_NEAR_Proto_FullAccessPermission()
    }
    set {permission = .fullAccess(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Permission
  public enum OneOf_Permission: Equatable {
    case functionCall(TW_NEAR_Proto_FunctionCallPermission)
    case fullAccess(TW_NEAR_Proto_FullAccessPermission)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_NEAR_Proto_AccessKey.OneOf_Permission, rhs: TW_NEAR_Proto_AccessKey.OneOf_Permission) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.functionCall, .functionCall): return {
        guard case .functionCall(let l) = lhs, case .functionCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fullAccess, .fullAccess): return {
        guard case .fullAccess(let l) = lhs, case .fullAccess(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Create Account
public struct TW_NEAR_Proto_CreateAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Deploying a contract
public struct TW_NEAR_Proto_DeployContract {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var code: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A method/function call
public struct TW_NEAR_Proto_FunctionCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Method/function name
  public var methodName: String = String()

  /// input arguments
  public var args: Data = Data()

  /// gas
  public var gas: UInt64 = 0

  /// uint128 / big endian byte order
  public var deposit: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Transfer
public struct TW_NEAR_Proto_Transfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// amount; uint128 / big endian byte order
  public var deposit: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Stake
public struct TW_NEAR_Proto_Stake {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// amount; uint128 / big endian byte order
  public var stake: Data = Data()

  /// owner public key
  public var publicKey: TW_NEAR_Proto_PublicKey {
    get {return _publicKey ?? TW_NEAR_Proto_PublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {self._publicKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _publicKey: TW_NEAR_Proto_PublicKey? = nil
}

/// Add a key
public struct TW_NEAR_Proto_AddKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var publicKey: TW_NEAR_Proto_PublicKey {
    get {return _publicKey ?? TW_NEAR_Proto_PublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {self._publicKey = nil}

  public var accessKey: TW_NEAR_Proto_AccessKey {
    get {return _accessKey ?? TW_NEAR_Proto_AccessKey()}
    set {_accessKey = newValue}
  }
  /// Returns true if `accessKey` has been explicitly set.
  public var hasAccessKey: Bool {return self._accessKey != nil}
  /// Clears the value of `accessKey`. Subsequent reads from it will return its default value.
  public mutating func clearAccessKey() {self._accessKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _publicKey: TW_NEAR_Proto_PublicKey? = nil
  fileprivate var _accessKey: TW_NEAR_Proto_AccessKey? = nil
}

/// Delete a key
public struct TW_NEAR_Proto_DeleteKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var publicKey: TW_NEAR_Proto_PublicKey {
    get {return _publicKey ?? TW_NEAR_Proto_PublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {self._publicKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _publicKey: TW_NEAR_Proto_PublicKey? = nil
}

/// Delete account
public struct TW_NEAR_Proto_DeleteAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var beneficiaryID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Fungible token transfer
public struct TW_NEAR_Proto_TokenTransfer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Token amount. Base-10 decimal string.
  public var tokenAmount: String = String()

  /// ID of the receiver.
  public var receiverID: String = String()

  /// Gas.
  public var gas: UInt64 = 0

  /// NEAR deposit amount; uint128 / big endian byte order.
  public var deposit: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents an action
public struct TW_NEAR_Proto_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var payload: TW_NEAR_Proto_Action.OneOf_Payload? = nil

  public var createAccount: TW_NEAR_Proto_CreateAccount {
    get {
      if case .createAccount(let v)? = payload {return v}
      return TW_NEAR_Proto_CreateAccount()
    }
    set {payload = .createAccount(newValue)}
  }

  public var deployContract: TW_NEAR_Proto_DeployContract {
    get {
      if case .deployContract(let v)? = payload {return v}
      return TW_NEAR_Proto_DeployContract()
    }
    set {payload = .deployContract(newValue)}
  }

  public var functionCall: TW_NEAR_Proto_FunctionCall {
    get {
      if case .functionCall(let v)? = payload {return v}
      return TW_NEAR_Proto_FunctionCall()
    }
    set {payload = .functionCall(newValue)}
  }

  public var transfer: TW_NEAR_Proto_Transfer {
    get {
      if case .transfer(let v)? = payload {return v}
      return TW_NEAR_Proto_Transfer()
    }
    set {payload = .transfer(newValue)}
  }

  public var stake: TW_NEAR_Proto_Stake {
    get {
      if case .stake(let v)? = payload {return v}
      return TW_NEAR_Proto_Stake()
    }
    set {payload = .stake(newValue)}
  }

  public var addKey: TW_NEAR_Proto_AddKey {
    get {
      if case .addKey(let v)? = payload {return v}
      return TW_NEAR_Proto_AddKey()
    }
    set {payload = .addKey(newValue)}
  }

  public var deleteKey: TW_NEAR_Proto_DeleteKey {
    get {
      if case .deleteKey(let v)? = payload {return v}
      return TW_NEAR_Proto_DeleteKey()
    }
    set {payload = .deleteKey(newValue)}
  }

  public var deleteAccount: TW_NEAR_Proto_DeleteAccount {
    get {
      if case .deleteAccount(let v)? = payload {return v}
      return TW_NEAR_Proto_DeleteAccount()
    }
    set {payload = .deleteAccount(newValue)}
  }

  /// Gap in field numbering is intentional as it's not a standard NEAR action.
  public var tokenTransfer: TW_NEAR_Proto_TokenTransfer {
    get {
      if case .tokenTransfer(let v)? = payload {return v}
      return TW_NEAR_Proto_TokenTransfer()
    }
    set {payload = .tokenTransfer(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Payload: Equatable {
    case createAccount(TW_NEAR_Proto_CreateAccount)
    case deployContract(TW_NEAR_Proto_DeployContract)
    case functionCall(TW_NEAR_Proto_FunctionCall)
    case transfer(TW_NEAR_Proto_Transfer)
    case stake(TW_NEAR_Proto_Stake)
    case addKey(TW_NEAR_Proto_AddKey)
    case deleteKey(TW_NEAR_Proto_DeleteKey)
    case deleteAccount(TW_NEAR_Proto_DeleteAccount)
    /// Gap in field numbering is intentional as it's not a standard NEAR action.
    case tokenTransfer(TW_NEAR_Proto_TokenTransfer)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_NEAR_Proto_Action.OneOf_Payload, rhs: TW_NEAR_Proto_Action.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.createAccount, .createAccount): return {
        guard case .createAccount(let l) = lhs, case .createAccount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deployContract, .deployContract): return {
        guard case .deployContract(let l) = lhs, case .deployContract(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.functionCall, .functionCall): return {
        guard case .functionCall(let l) = lhs, case .functionCall(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transfer, .transfer): return {
        guard case .transfer(let l) = lhs, case .transfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stake, .stake): return {
        guard case .stake(let l) = lhs, case .stake(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.addKey, .addKey): return {
        guard case .addKey(let l) = lhs, case .addKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteKey, .deleteKey): return {
        guard case .deleteKey(let l) = lhs, case .deleteKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteAccount, .deleteAccount): return {
        guard case .deleteAccount(let l) = lhs, case .deleteAccount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tokenTransfer, .tokenTransfer): return {
        guard case .tokenTransfer(let l) = lhs, case .tokenTransfer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Input data necessary to create a signed order.
public struct TW_NEAR_Proto_SigningInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the sender
  public var signerID: String = String()

  /// Nonce (should be larger than in the last transaction of the account)
  public var nonce: UInt64 = 0

  /// ID of the receiver
  public var receiverID: String = String()

  /// Recent block hash
  public var blockHash: Data = Data()

  /// Payload action(s)
  public var actions: [TW_NEAR_Proto_Action] = []

  /// The secret private key used for signing (32 bytes).
  public var privateKey: Data = Data()

  /// The public key used for compiling a transaction with a signature.
  public var publicKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Result containing the signed and encoded transaction.
public struct TW_NEAR_Proto_SigningOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Signed transaction blob
  public var signedTransaction: Data = Data()

  /// error code, 0 is ok, other codes will be treated as errors
  public var error: TW_Common_Proto_SigningError = .ok

  /// error code description
  public var errorMessage: String = String()

  /// Hash of the transaction
  public var hash: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TW.NEAR.Proto"

extension TW_NEAR_Proto_PublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_type"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.keyType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyType != 0 {
      try visitor.visitSingularUInt32Field(value: self.keyType, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_PublicKey, rhs: TW_NEAR_Proto_PublicKey) -> Bool {
    if lhs.keyType != rhs.keyType {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_FunctionCallPermission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FunctionCallPermission"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "allowance"),
    2: .standard(proto: "receiver_id"),
    3: .standard(proto: "method_names"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.allowance) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.receiverID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.methodNames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowance.isEmpty {
      try visitor.visitSingularBytesField(value: self.allowance, fieldNumber: 1)
    }
    if !self.receiverID.isEmpty {
      try visitor.visitSingularStringField(value: self.receiverID, fieldNumber: 2)
    }
    if !self.methodNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.methodNames, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_FunctionCallPermission, rhs: TW_NEAR_Proto_FunctionCallPermission) -> Bool {
    if lhs.allowance != rhs.allowance {return false}
    if lhs.receiverID != rhs.receiverID {return false}
    if lhs.methodNames != rhs.methodNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_FullAccessPermission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FullAccessPermission"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_FullAccessPermission, rhs: TW_NEAR_Proto_FullAccessPermission) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_AccessKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .standard(proto: "function_call"),
    3: .standard(proto: "full_access"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      case 2: try {
        var v: TW_NEAR_Proto_FunctionCallPermission?
        var hadOneofValue = false
        if let current = self.permission {
          hadOneofValue = true
          if case .functionCall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.permission = .functionCall(v)
        }
      }()
      case 3: try {
        var v: TW_NEAR_Proto_FullAccessPermission?
        var hadOneofValue = false
        if let current = self.permission {
          hadOneofValue = true
          if case .fullAccess(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.permission = .fullAccess(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 1)
    }
    switch self.permission {
    case .functionCall?: try {
      guard case .functionCall(let v)? = self.permission else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .fullAccess?: try {
      guard case .fullAccess(let v)? = self.permission else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_AccessKey, rhs: TW_NEAR_Proto_AccessKey) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.permission != rhs.permission {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_CreateAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAccount"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_CreateAccount, rhs: TW_NEAR_Proto_CreateAccount) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_DeployContract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeployContract"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularBytesField(value: self.code, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_DeployContract, rhs: TW_NEAR_Proto_DeployContract) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_FunctionCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FunctionCall"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "method_name"),
    2: .same(proto: "args"),
    3: .same(proto: "gas"),
    4: .same(proto: "deposit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.methodName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.args) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.gas) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.deposit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.methodName.isEmpty {
      try visitor.visitSingularStringField(value: self.methodName, fieldNumber: 1)
    }
    if !self.args.isEmpty {
      try visitor.visitSingularBytesField(value: self.args, fieldNumber: 2)
    }
    if self.gas != 0 {
      try visitor.visitSingularUInt64Field(value: self.gas, fieldNumber: 3)
    }
    if !self.deposit.isEmpty {
      try visitor.visitSingularBytesField(value: self.deposit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_FunctionCall, rhs: TW_NEAR_Proto_FunctionCall) -> Bool {
    if lhs.methodName != rhs.methodName {return false}
    if lhs.args != rhs.args {return false}
    if lhs.gas != rhs.gas {return false}
    if lhs.deposit != rhs.deposit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_Transfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transfer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "deposit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.deposit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deposit.isEmpty {
      try visitor.visitSingularBytesField(value: self.deposit, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_Transfer, rhs: TW_NEAR_Proto_Transfer) -> Bool {
    if lhs.deposit != rhs.deposit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_Stake: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Stake"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stake"),
    2: .standard(proto: "public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.stake) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.stake.isEmpty {
      try visitor.visitSingularBytesField(value: self.stake, fieldNumber: 1)
    }
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_Stake, rhs: TW_NEAR_Proto_Stake) -> Bool {
    if lhs.stake != rhs.stake {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_AddKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "access_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accessKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accessKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_AddKey, rhs: TW_NEAR_Proto_AddKey) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._accessKey != rhs._accessKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_DeleteKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_DeleteKey, rhs: TW_NEAR_Proto_DeleteKey) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_DeleteAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "beneficiary_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.beneficiaryID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.beneficiaryID.isEmpty {
      try visitor.visitSingularStringField(value: self.beneficiaryID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_DeleteAccount, rhs: TW_NEAR_Proto_DeleteAccount) -> Bool {
    if lhs.beneficiaryID != rhs.beneficiaryID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_TokenTransfer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenTransfer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_amount"),
    2: .standard(proto: "receiver_id"),
    3: .same(proto: "gas"),
    4: .same(proto: "deposit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenAmount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.receiverID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.gas) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.deposit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenAmount.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenAmount, fieldNumber: 1)
    }
    if !self.receiverID.isEmpty {
      try visitor.visitSingularStringField(value: self.receiverID, fieldNumber: 2)
    }
    if self.gas != 0 {
      try visitor.visitSingularUInt64Field(value: self.gas, fieldNumber: 3)
    }
    if !self.deposit.isEmpty {
      try visitor.visitSingularBytesField(value: self.deposit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_TokenTransfer, rhs: TW_NEAR_Proto_TokenTransfer) -> Bool {
    if lhs.tokenAmount != rhs.tokenAmount {return false}
    if lhs.receiverID != rhs.receiverID {return false}
    if lhs.gas != rhs.gas {return false}
    if lhs.deposit != rhs.deposit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "create_account"),
    2: .standard(proto: "deploy_contract"),
    3: .standard(proto: "function_call"),
    4: .same(proto: "transfer"),
    5: .same(proto: "stake"),
    6: .standard(proto: "add_key"),
    7: .standard(proto: "delete_key"),
    8: .standard(proto: "delete_account"),
    13: .standard(proto: "token_transfer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: TW_NEAR_Proto_CreateAccount?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .createAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .createAccount(v)
        }
      }()
      case 2: try {
        var v: TW_NEAR_Proto_DeployContract?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .deployContract(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .deployContract(v)
        }
      }()
      case 3: try {
        var v: TW_NEAR_Proto_FunctionCall?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .functionCall(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .functionCall(v)
        }
      }()
      case 4: try {
        var v: TW_NEAR_Proto_Transfer?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .transfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .transfer(v)
        }
      }()
      case 5: try {
        var v: TW_NEAR_Proto_Stake?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .stake(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .stake(v)
        }
      }()
      case 6: try {
        var v: TW_NEAR_Proto_AddKey?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .addKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .addKey(v)
        }
      }()
      case 7: try {
        var v: TW_NEAR_Proto_DeleteKey?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .deleteKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .deleteKey(v)
        }
      }()
      case 8: try {
        var v: TW_NEAR_Proto_DeleteAccount?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .deleteAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .deleteAccount(v)
        }
      }()
      case 13: try {
        var v: TW_NEAR_Proto_TokenTransfer?
        var hadOneofValue = false
        if let current = self.payload {
          hadOneofValue = true
          if case .tokenTransfer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.payload = .tokenTransfer(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.payload {
    case .createAccount?: try {
      guard case .createAccount(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .deployContract?: try {
      guard case .deployContract(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .functionCall?: try {
      guard case .functionCall(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .transfer?: try {
      guard case .transfer(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .stake?: try {
      guard case .stake(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .addKey?: try {
      guard case .addKey(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .deleteKey?: try {
      guard case .deleteKey(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .deleteAccount?: try {
      guard case .deleteAccount(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .tokenTransfer?: try {
      guard case .tokenTransfer(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_Action, rhs: TW_NEAR_Proto_Action) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_SigningInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigningInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signer_id"),
    2: .same(proto: "nonce"),
    3: .standard(proto: "receiver_id"),
    4: .standard(proto: "block_hash"),
    5: .same(proto: "actions"),
    6: .standard(proto: "private_key"),
    7: .standard(proto: "public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signerID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.nonce) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.receiverID) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.blockHash) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.privateKey) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signerID.isEmpty {
      try visitor.visitSingularStringField(value: self.signerID, fieldNumber: 1)
    }
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 2)
    }
    if !self.receiverID.isEmpty {
      try visitor.visitSingularStringField(value: self.receiverID, fieldNumber: 3)
    }
    if !self.blockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.blockHash, fieldNumber: 4)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 5)
    }
    if !self.privateKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKey, fieldNumber: 6)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_SigningInput, rhs: TW_NEAR_Proto_SigningInput) -> Bool {
    if lhs.signerID != rhs.signerID {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.receiverID != rhs.receiverID {return false}
    if lhs.blockHash != rhs.blockHash {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_NEAR_Proto_SigningOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SigningOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signed_transaction"),
    2: .same(proto: "error"),
    3: .standard(proto: "error_message"),
    4: .same(proto: "hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signedTransaction) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.error) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signedTransaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedTransaction, fieldNumber: 1)
    }
    if self.error != .ok {
      try visitor.visitSingularEnumField(value: self.error, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_NEAR_Proto_SigningOutput, rhs: TW_NEAR_Proto_SigningOutput) -> Bool {
    if lhs.signedTransaction != rhs.signedTransaction {return false}
    if lhs.error != rhs.error {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
