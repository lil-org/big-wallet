// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: LiquidStaking.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright Â© 2017-2023 Trust Wallet.
//
// This file is part of Trust. The full Trust copyright notice, including
// terms governing use, modification, and redistribution, is contained in the
// file LICENSE at the root of the source code distribution tree.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Enum for supported coins for liquid staking
public enum TW_LiquidStaking_Proto_Coin: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case matic // = 0
  case atom // = 1
  case bnb // = 2
  case apt // = 3
  case eth // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .matic
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .matic
    case 1: self = .atom
    case 2: self = .bnb
    case 3: self = .apt
    case 4: self = .eth
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .matic: return 0
    case .atom: return 1
    case .bnb: return 2
    case .apt: return 3
    case .eth: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TW_LiquidStaking_Proto_Coin: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TW_LiquidStaking_Proto_Coin] = [
    .matic,
    .atom,
    .bnb,
    .apt,
    .eth,
  ]
}

#endif  // swift(>=4.2)

/// Enum for supported target blockchains for liquid staking
public enum TW_LiquidStaking_Proto_Blockchain: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case ethereum // = 0
  case polygon // = 1
  case stride // = 2
  case bnbBsc // = 3
  case aptos // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .ethereum
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ethereum
    case 1: self = .polygon
    case 2: self = .stride
    case 3: self = .bnbBsc
    case 4: self = .aptos
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .ethereum: return 0
    case .polygon: return 1
    case .stride: return 2
    case .bnbBsc: return 3
    case .aptos: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TW_LiquidStaking_Proto_Blockchain: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TW_LiquidStaking_Proto_Blockchain] = [
    .ethereum,
    .polygon,
    .stride,
    .bnbBsc,
    .aptos,
  ]
}

#endif  // swift(>=4.2)

/// Enum for supported liquid staking protocols
public enum TW_LiquidStaking_Proto_Protocol: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case strader // = 0
  case stride // = 1
  case tortuga // = 2
  case lido // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .strader
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .strader
    case 1: self = .stride
    case 2: self = .tortuga
    case 3: self = .lido
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .strader: return 0
    case .stride: return 1
    case .tortuga: return 2
    case .lido: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TW_LiquidStaking_Proto_Protocol: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TW_LiquidStaking_Proto_Protocol] = [
    .strader,
    .stride,
    .tortuga,
    .lido,
  ]
}

#endif  // swift(>=4.2)

/// Enum for status codes to indicate the result of an operation
public enum TW_LiquidStaking_Proto_StatusCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case ok // = 0
  case errorActionNotSet // = 1
  case errorTargetedBlockchainNotSupportedByProtocol // = 2
  case errorSmartContractAddressNotSet // = 3
  case errorInputProtoDeserialization // = 4
  case errorOperationNotSupportedByProtocol // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .ok
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .errorActionNotSet
    case 2: self = .errorTargetedBlockchainNotSupportedByProtocol
    case 3: self = .errorSmartContractAddressNotSet
    case 4: self = .errorInputProtoDeserialization
    case 5: self = .errorOperationNotSupportedByProtocol
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .ok: return 0
    case .errorActionNotSet: return 1
    case .errorTargetedBlockchainNotSupportedByProtocol: return 2
    case .errorSmartContractAddressNotSet: return 3
    case .errorInputProtoDeserialization: return 4
    case .errorOperationNotSupportedByProtocol: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TW_LiquidStaking_Proto_StatusCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [TW_LiquidStaking_Proto_StatusCode] = [
    .ok,
    .errorActionNotSet,
    .errorTargetedBlockchainNotSupportedByProtocol,
    .errorSmartContractAddressNotSet,
    .errorInputProtoDeserialization,
    .errorOperationNotSupportedByProtocol,
  ]
}

#endif  // swift(>=4.2)

/// Message to represent the status of an operation
public struct TW_LiquidStaking_Proto_Status {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status code of the operation
  public var code: TW_LiquidStaking_Proto_StatusCode = .ok

  /// Optional error message, populated in case of error
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message to represent the asset for staking operations
public struct TW_LiquidStaking_Proto_Asset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Coin to be staked
  public var stakingToken: TW_LiquidStaking_Proto_Coin = .matic

  /// Optional, liquid_token to be manipulated: unstake, claim rewards
  public var liquidToken: String = String()

  /// Denom of the asset to be manipulated, required by some liquid staking protocols
  public var denom: String = String()

  /// Address for building the appropriate input
  public var fromAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message to represent a stake operation
public struct TW_LiquidStaking_Proto_Stake {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var asset: TW_LiquidStaking_Proto_Asset {
    get {return _asset ?? TW_LiquidStaking_Proto_Asset()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  public var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  public mutating func clearAsset() {self._asset = nil}

  public var amount: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _asset: TW_LiquidStaking_Proto_Asset? = nil
}

/// Message to represent an unstake operation
public struct TW_LiquidStaking_Proto_Unstake {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var asset: TW_LiquidStaking_Proto_Asset {
    get {return _asset ?? TW_LiquidStaking_Proto_Asset()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  public var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  public mutating func clearAsset() {self._asset = nil}

  public var amount: String = String()

  /// Some cross-chain protocols propose u to setup a receiver_address
  public var receiverAddress: String = String()

  /// Some cross-chain protocols propose u to set the receiver chain_id, it allows auto-claim after probation period
  public var receiverChainID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _asset: TW_LiquidStaking_Proto_Asset? = nil
}

/// Message to represent a withdraw operation
public struct TW_LiquidStaking_Proto_Withdraw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var asset: TW_LiquidStaking_Proto_Asset {
    get {return _asset ?? TW_LiquidStaking_Proto_Asset()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  public var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  public mutating func clearAsset() {self._asset = nil}

  public var amount: String = String()

  /// Sometimes withdraw is just the index of a request, amount is already known by the SC
  public var idx: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _asset: TW_LiquidStaking_Proto_Asset? = nil
}

/// Message to represent the input for a liquid staking operation
public struct TW_LiquidStaking_Proto_Input {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Oneof field to specify the action: stake, unstake or withdraw
  public var action: TW_LiquidStaking_Proto_Input.OneOf_Action? = nil

  public var stake: TW_LiquidStaking_Proto_Stake {
    get {
      if case .stake(let v)? = action {return v}
      return TW_LiquidStaking_Proto_Stake()
    }
    set {action = .stake(newValue)}
  }

  public var unstake: TW_LiquidStaking_Proto_Unstake {
    get {
      if case .unstake(let v)? = action {return v}
      return TW_LiquidStaking_Proto_Unstake()
    }
    set {action = .unstake(newValue)}
  }

  public var withdraw: TW_LiquidStaking_Proto_Withdraw {
    get {
      if case .withdraw(let v)? = action {return v}
      return TW_LiquidStaking_Proto_Withdraw()
    }
    set {action = .withdraw(newValue)}
  }

  /// Optional smart contract address for EVM-based chains
  public var smartContractAddress: String = String()

  /// Protocol to be used for liquid staking
  public var `protocol`: TW_LiquidStaking_Proto_Protocol = .strader

  /// Target blockchain for the liquid staking operation
  public var blockchain: TW_LiquidStaking_Proto_Blockchain = .ethereum

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Oneof field to specify the action: stake, unstake or withdraw
  public enum OneOf_Action: Equatable {
    case stake(TW_LiquidStaking_Proto_Stake)
    case unstake(TW_LiquidStaking_Proto_Unstake)
    case withdraw(TW_LiquidStaking_Proto_Withdraw)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_LiquidStaking_Proto_Input.OneOf_Action, rhs: TW_LiquidStaking_Proto_Input.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stake, .stake): return {
        guard case .stake(let l) = lhs, case .stake(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unstake, .unstake): return {
        guard case .unstake(let l) = lhs, case .unstake(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withdraw, .withdraw): return {
        guard case .withdraw(let l) = lhs, case .withdraw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Message to represent the output of a liquid staking operation
public struct TW_LiquidStaking_Proto_Output {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status of the liquid staking operation
  public var status: TW_LiquidStaking_Proto_Status {
    get {return _status ?? TW_LiquidStaking_Proto_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// Unsigned transaction input - needs to be completed and signed
  public var signingInputOneof: TW_LiquidStaking_Proto_Output.OneOf_SigningInputOneof? = nil

  public var ethereum: TW_Ethereum_Proto_SigningInput {
    get {
      if case .ethereum(let v)? = signingInputOneof {return v}
      return TW_Ethereum_Proto_SigningInput()
    }
    set {signingInputOneof = .ethereum(newValue)}
  }

  public var cosmos: TW_Cosmos_Proto_SigningInput {
    get {
      if case .cosmos(let v)? = signingInputOneof {return v}
      return TW_Cosmos_Proto_SigningInput()
    }
    set {signingInputOneof = .cosmos(newValue)}
  }

  public var aptos: TW_Aptos_Proto_SigningInput {
    get {
      if case .aptos(let v)? = signingInputOneof {return v}
      return TW_Aptos_Proto_SigningInput()
    }
    set {signingInputOneof = .aptos(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Unsigned transaction input - needs to be completed and signed
  public enum OneOf_SigningInputOneof: Equatable {
    case ethereum(TW_Ethereum_Proto_SigningInput)
    case cosmos(TW_Cosmos_Proto_SigningInput)
    case aptos(TW_Aptos_Proto_SigningInput)

  #if !swift(>=4.1)
    public static func ==(lhs: TW_LiquidStaking_Proto_Output.OneOf_SigningInputOneof, rhs: TW_LiquidStaking_Proto_Output.OneOf_SigningInputOneof) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.ethereum, .ethereum): return {
        guard case .ethereum(let l) = lhs, case .ethereum(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cosmos, .cosmos): return {
        guard case .cosmos(let l) = lhs, case .cosmos(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.aptos, .aptos): return {
        guard case .aptos(let l) = lhs, case .aptos(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _status: TW_LiquidStaking_Proto_Status? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "TW.LiquidStaking.Proto"

extension TW_LiquidStaking_Proto_Coin: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MATIC"),
    1: .same(proto: "ATOM"),
    2: .same(proto: "BNB"),
    3: .same(proto: "APT"),
    4: .same(proto: "ETH"),
  ]
}

extension TW_LiquidStaking_Proto_Blockchain: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ETHEREUM"),
    1: .same(proto: "POLYGON"),
    2: .same(proto: "STRIDE"),
    3: .same(proto: "BNB_BSC"),
    4: .same(proto: "APTOS"),
  ]
}

extension TW_LiquidStaking_Proto_Protocol: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Strader"),
    1: .same(proto: "Stride"),
    2: .same(proto: "Tortuga"),
    3: .same(proto: "Lido"),
  ]
}

extension TW_LiquidStaking_Proto_StatusCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "ERROR_ACTION_NOT_SET"),
    2: .same(proto: "ERROR_TARGETED_BLOCKCHAIN_NOT_SUPPORTED_BY_PROTOCOL"),
    3: .same(proto: "ERROR_SMART_CONTRACT_ADDRESS_NOT_SET"),
    4: .same(proto: "ERROR_INPUT_PROTO_DESERIALIZATION"),
    5: .same(proto: "ERROR_OPERATION_NOT_SUPPORTED_BY_PROTOCOL"),
  ]
}

extension TW_LiquidStaking_Proto_Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Status"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_LiquidStaking_Proto_Status, rhs: TW_LiquidStaking_Proto_Status) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_LiquidStaking_Proto_Asset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Asset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "staking_token"),
    2: .standard(proto: "liquid_token"),
    3: .same(proto: "denom"),
    4: .standard(proto: "from_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.stakingToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.liquidToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fromAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.stakingToken != .matic {
      try visitor.visitSingularEnumField(value: self.stakingToken, fieldNumber: 1)
    }
    if !self.liquidToken.isEmpty {
      try visitor.visitSingularStringField(value: self.liquidToken, fieldNumber: 2)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 3)
    }
    if !self.fromAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.fromAddress, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_LiquidStaking_Proto_Asset, rhs: TW_LiquidStaking_Proto_Asset) -> Bool {
    if lhs.stakingToken != rhs.stakingToken {return false}
    if lhs.liquidToken != rhs.liquidToken {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.fromAddress != rhs.fromAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_LiquidStaking_Proto_Stake: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Stake"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asset"),
    2: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_LiquidStaking_Proto_Stake, rhs: TW_LiquidStaking_Proto_Stake) -> Bool {
    if lhs._asset != rhs._asset {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_LiquidStaking_Proto_Unstake: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Unstake"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asset"),
    2: .same(proto: "amount"),
    3: .standard(proto: "receiver_address"),
    4: .standard(proto: "receiver_chain_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.receiverAddress) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.receiverChainID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    if !self.receiverAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.receiverAddress, fieldNumber: 3)
    }
    if !self.receiverChainID.isEmpty {
      try visitor.visitSingularStringField(value: self.receiverChainID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_LiquidStaking_Proto_Unstake, rhs: TW_LiquidStaking_Proto_Unstake) -> Bool {
    if lhs._asset != rhs._asset {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.receiverAddress != rhs.receiverAddress {return false}
    if lhs.receiverChainID != rhs.receiverChainID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_LiquidStaking_Proto_Withdraw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Withdraw"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "asset"),
    2: .same(proto: "amount"),
    3: .same(proto: "idx"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.amount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.idx) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 2)
    }
    if !self.idx.isEmpty {
      try visitor.visitSingularStringField(value: self.idx, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_LiquidStaking_Proto_Withdraw, rhs: TW_LiquidStaking_Proto_Withdraw) -> Bool {
    if lhs._asset != rhs._asset {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.idx != rhs.idx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_LiquidStaking_Proto_Input: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Input"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stake"),
    2: .same(proto: "unstake"),
    3: .same(proto: "withdraw"),
    4: .standard(proto: "smart_contract_address"),
    5: .same(proto: "protocol"),
    6: .same(proto: "blockchain"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: TW_LiquidStaking_Proto_Stake?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .stake(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .stake(v)
        }
      }()
      case 2: try {
        var v: TW_LiquidStaking_Proto_Unstake?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .unstake(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .unstake(v)
        }
      }()
      case 3: try {
        var v: TW_LiquidStaking_Proto_Withdraw?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .withdraw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .withdraw(v)
        }
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.smartContractAddress) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.`protocol`) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.blockchain) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.action {
    case .stake?: try {
      guard case .stake(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .unstake?: try {
      guard case .unstake(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .withdraw?: try {
      guard case .withdraw(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.smartContractAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.smartContractAddress, fieldNumber: 4)
    }
    if self.`protocol` != .strader {
      try visitor.visitSingularEnumField(value: self.`protocol`, fieldNumber: 5)
    }
    if self.blockchain != .ethereum {
      try visitor.visitSingularEnumField(value: self.blockchain, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_LiquidStaking_Proto_Input, rhs: TW_LiquidStaking_Proto_Input) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.smartContractAddress != rhs.smartContractAddress {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.blockchain != rhs.blockchain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TW_LiquidStaking_Proto_Output: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Output"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "ethereum"),
    3: .same(proto: "cosmos"),
    4: .same(proto: "aptos"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try {
        var v: TW_Ethereum_Proto_SigningInput?
        var hadOneofValue = false
        if let current = self.signingInputOneof {
          hadOneofValue = true
          if case .ethereum(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signingInputOneof = .ethereum(v)
        }
      }()
      case 3: try {
        var v: TW_Cosmos_Proto_SigningInput?
        var hadOneofValue = false
        if let current = self.signingInputOneof {
          hadOneofValue = true
          if case .cosmos(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signingInputOneof = .cosmos(v)
        }
      }()
      case 4: try {
        var v: TW_Aptos_Proto_SigningInput?
        var hadOneofValue = false
        if let current = self.signingInputOneof {
          hadOneofValue = true
          if case .aptos(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.signingInputOneof = .aptos(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.signingInputOneof {
    case .ethereum?: try {
      guard case .ethereum(let v)? = self.signingInputOneof else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cosmos?: try {
      guard case .cosmos(let v)? = self.signingInputOneof else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .aptos?: try {
      guard case .aptos(let v)? = self.signingInputOneof else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TW_LiquidStaking_Proto_Output, rhs: TW_LiquidStaking_Proto_Output) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.signingInputOneof != rhs.signingInputOneof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
